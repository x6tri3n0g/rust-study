# 일반적인 프로그래밍 개념

이 장은 러스트 고유의 개념은 없지만, 러스트의 맥락에서 논의하고 이러한 개념 사용과 관련된 규칙을 설명합니다.  
  
특히 변수, 기본 타입, 함수, 주석 그리고 제어 흐름에 대해서 알아봅니다.

## 변수와 가변성
- **변수는 기본적으로 불변(immutable)**
  - 러스트가 제공하는 안정성과 쉬운 동시성을 활용하는 방식으로 코드를 작성할 수 있도록 하는 넛지(nudge, 슬며시 선택을 유도하기) 중 하나
  - 그렇지만, 필요하다면 가변(mutable)으로 만들 수도 있음
- 변수가 불변일 때, 그 값이 변수에 대입되면 그 값은 바꿀 수 없음

실제 코드로 어떻게 동작하는지 확인해봅니다.
```shell
$ cargo new variables
```
- `variables`라는 이름의 프로젝트를 생성

main.rs와 아래와 같이 작성합니다.
```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

실행해봅니다.
```shell
$ cargo run
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to previous error
```
- 컴파일러는 에러가 있다는 것을 알려줌
  - 메세지의 내용을 보면 `불변 변수 x에 두 번 값을 할당할 수 없다`라고 합니다.  
- 불변으로 지정한 값을 변경하려고 하는 상황이 버그로 이어질 수 있기 때문에, 컴팡일 타임 에러가 발생하는 것은 중요함
- 변수의 쉬운 변경으로 인해 같은 값을 바라보는 서로 다른 일에 영향을 줄수 있음 
  - 이는 버그를 발생 
  - 러스트 컴파일러는 값이 바뀌지 않을 것이라고 지정하면 실제로 그렇도록 보증 
    - 이 규칙을 통해 값이 실제로 어디서 변경될 것인지 추적하지 않아도 됨
- 때때로 가변성은 유용하기도 하며, 코드 작성을 더 편하게 함
  - 가변성을 가진 변수를 만들기 위해서는 `mut`을 붙여서 가변으로 만들 수 있음

main.rs를 아래와 같이 수정합니다.
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

그럼 다음 출력을 볼 수 있습니다.
```shell
$ cargo run
Compiling variables v0.1.0 (/Users/xtring/Study/rust-study/rust-kr/03_common_programming_concepts/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

이렇게 `mut`를 사용해 변수의 값을 변경할 수 있습니다. 

### 상수
- *상수(constant)* 는 불변 변수와 비슷한데, 어떤 변수에 묶여 있는 값이고 값을 바꾸는 것이 허용되지 않지만, 변수와는 약간 다른 점들이 있음
- 상수는 `mut`와 함께 사용할 수 없음
  - 상수는 기본적으로 불변인 것이 아니고, **항상 불변**
  - 상수는 `let`이 아닌 `const` 키워드로 선언
  - *타입이 반드시 명시되어야 함*
  - 상수는 반드시 런타임에서만 계산할 수 있는 값의 결과가 아니라 *상수 표현식으로만 설정할 수 있음*
  - 예를 들어 `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`인 상수는 이와 같이 `대문자`로 표현되면 단어 사이에는 `_`를 사용
    - 컴파일러는 컴파일 타임에 *제한된 연산*을 사용하여 해당 상수를 10,800으로 계산하고 고정해둡니다.
- 이렇게 특정한 의미가 있는 값에 의미가 있는 이름을 붙임으로서 미래의 코드 관리자에게 그 값의 의미를 전달하는데 유용함
  - 또, 나중에 업데이트될 하드코딩된 값을 단 한 군데에서 변경할 수 있게 함

### 섀도잉
- 2장 추리게임 코드에서도 보았듯이, 새 변수를 이전 변수명과 같은 이름으로 선언하여 사용할 수 있음
  - 첫 번째 변수가 두 번째 변수에 의해 *가려졌다(shadowed)* 라고 표현하며, 이는 해당 변수의 이름을 사용할 때 컴파일러가 두 번째 변수를 바라보게 될 것임을 의미함
  - 아래 예제와 같이 똑같은 변수명과 `let` 키워드를 통해 반복적으로 shadowing 할 수 있음

main.rs
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }
    
    println!("The value of x is: {x}");
}
```

실행 후 결과는 아래와 같습니다.
```shell
$ cargo run
Compiling variables v0.1.0 (/Users/xtring/Study/rust-study/rust-kr/03_common_programming_concepts/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/variables`   
The value of x in the inner scope is: 12
The value of x is: 6
```
  
- 섀도잉은 변수를 `mut`로 표시하는 것과 다름
  - 실수로 `let` 키워드 없이 변수에 값을 재할당하려고 하면 컴파일 타임 에러가 발생하기 때문
  - `let`을 사용하며느 값을 변형하면서 변형이 완료된 후에는 불변으로 유지할 수 있음
  - 섀도잉은 다시금 `let` 키워드를 사용하여 새로운 변수를 만드는 것이기 때문에 같은 변수명으로 다른 타입의 값을 저장할 수 있음
```rust
// ok - 타입이 변경되어도 가능
let spaces = "   ";
let spaces = spaces.len();

// nop - 변경가능한 변수에 다른 타입의 값을 재할당하려고 하기 때문에 컴파일 에러 발생
let mut spaces = "   ";
spaces = spaces.len();
```

## 데이터 타입
> 러스트의 모든 값은 특정한 타입을 가지며, 이는 러스트가 해당 데이터로 작업하는 방법을 알 수 있도록 어떤 종류의 데이터가 지정되고 있는지 알려줍니다. 여기서는 타입을 스칼라 타입과 복합 타입, 두 가지 부분 집합으로 나누어 보겠습니다.
  
- 러스트는 *정적타입(statically typed)* 언어
  - 모든 변수의 타입이 컴파일 시점에 반드시 정해져 있어야 한다는 의미
    - 여러 가지 타입이 가능한 경우 타입을 명시해야함
      - `let guess: u32 = "42".parse().expect("Not a number!");`: String 타입의 "42"를 guess 변수에 다시 32bits 정수 타입으로 할당하는 경우
        - 타입을 지정하지 않으면 컴파일시 에러가 발생함

### 스칼라 타입
- *스칼라(scalar)* 타입은 하나의 값을 표현
  - 러스트는 정수, 부동 소수점 숫자, 불린(boolean), 문자 4가지 스칼라 타입을 갖고 있음

#### 정수형
- *정수형(integer type)* 은 소수점이 없는 숫자
  - 먼저 살펴본 `u32` 타입의 경우 부호가 없는 32비트 변수를 의미함(부호가 있는 타입: `i`)

|길이	|부호 있음 (signed)	|부호 없음 (unsigned)|
|--|--|--|
|8-bit	|i8	|u8
|16-bit	|i16	|u16
|32-bit	|i32	|u32
|64-bit	|i64	|u64
|128-bit	|i128	|u128
|arch	|isize	|usize

- 각각의 크기별 타입은 부호 있는(signed) 혹은 부호 없는(unsigned) 타입이며 명시된 크기를 가짐
- 부호 유무의 의미는 해당 타입이 음수를 다룰 수 있는지를 의미함
  - 부호 있는 숫자는 `2의 보수` 형태를 사용하여 저장
- 각 부호 있는 타입 변수는 `-(2^(n-1))` ~ `2^(n-1)-1`의 값을 저장할 수 있음
  - `n`은 사용되는 타입의 비트 수를 의미함
  - `u8` 타입은 0에서 2^8 - 1 다시 말해, 0에서 255까지의 값을 저장할 수 있음
- `isize`와 `usize` 타입은 사용자의 프로그램이 동작하는 컴퓨터 환경에 따라 결정됨
  - 위 표에서는 `arch`라고 적시됨
  - 64-bit라면 64비트, 32-bit라면 32비트 기반으로 설정
  

정수형 리터럴은 아래와 같은 형태로 작성 가능
- 여러 숫자 타입이 될 수 있는 숫자 리터럴에는 `57u8`과 같은 타입 접미사를 사용하여 타입을 지정 가능

|숫자 리터럴	|예 |
|--|--|
|Decimal	|98_222|
|Hex	|0xff|
|Octal	|0o77|
|Binary	|0b1111_0000|
|Byte (u8 only)	|b'A'|

> 어떤 타입의 정수를 사용해야 하는지는 어떻게 알아낼까요?  
  
  확실히 정해진 경우가 아니라면 러스트의 기본값인 `i32`가 일반적으로 좋은 시작 지점이 됩니다. `isize`나 `usize`는 주로 어떤 컬렉션 종류의 인덱스에 사용됩니다.

> 정수 오버플로우  
여러분이 0과 255 사이의 값을 담을 수 있는 u8 타입의 변수를 갖고 있다고 해봅시다. 만약에 이 변수에 256처럼 범위 밖의 값으로 변경하려고 하면 정수 오버플로우 (integer overflow) 가 일어나는데, 이는 둘 중 한 가지 동작을 일으킵니다. 코드를 디버그 모드에서 컴파일하는 경우, 러스트는 런타임에 정수 오버플로우가 발생했을 때 패닉 (panic) 을 발생시키는 검사를 포함시킵니다. 러스트에서는 에러가 발생하면서 프로그램이 종료되는 경우 패닉이라는 용어를 사용합니다; 9장의 ‘panic!으로 복구 불가능한 에러 처리하기’절에서 패닉에 대해 좀 더 자세히 다루겠습니다.  
--release 플래그를 사용하여 코드를 릴리즈 모드로 컴파일하는 경우에는 패닉을 발생시키는 정수 오버플로우 검사를 실행파일에 포함시키지 않습니다. 대신 오버플로우가 발생하면 러스트는 2의 보수 감싸기 (two's complement wrapping) 을 수행합니다. 짧게 설명하자면, 해당 타입이 가질 수 있는 최댓값보다 더 큰 값은 허용되는 최솟값으로 ‘돌아갑니다 (wrap around)’. u8의 경우 256은 0이, 257은 1이 되는 식입니다. 프로그램은 패닉을 발생시키지 않으나, 해당 변수는 아마도 여러분이 예상치 못했던 값을 갖게 될 겁니다. 정수 오버플로우의 감싸기 동작에 의존하는 것은 에러로 간주됩니다.  
명시적으로 오버플로우의 가능성을 다루기 위해서는 표준 라이브러리에서 기본 수치 타입에 대해 제공하는 아래 메서드 종류들을 사용할 수 있습니다:  
wrapping_add와 같은 wrapping_* 메서드로 감싸기 동작 실행하기
checked_* 메서드를 사용하여 오버플로우가 발생하면 None 값 반환하기
overflowing_* 메서드를 사용하여 값과 함께 오버플로우 발생이 있었는지를 알려주는 부울린 값 반환하기
saturating_* 메서드를 사용하여 값의 최대 혹은 최솟값 사이로 제한하기
  
#### 부동 소수점 타입
러스트의 *부동 소수점(floating-point) 숫자* 타입에는 두가지가 있습니다. 
- `f32`, `f64`
  - 기본 타입은 `f64`
    - 이뉴는 현대의 CPU 상에서 `f64`가 `f32`와 비슷한 속도를 내면서도 더 정밀하기 때문. 모든 부동 소수점 타입은 부호가 있음
```rust
let x = 2.0; // f64
let y: f32 = 3.0; // f32
```
- 부동 소수점 숫자는 IEEE-754 표준을 따름
- `f32` 타입은 1배수 정밀도(single-precision)인 부동 소수점
- `f64` 타입은 2배수 정밀도(double-precision)인 부동 소수점


#### 수치 연산
*다른 언어와 큰 차이없어 패스*


#### 부울린 타입
*다른 언어와 큰 차이없어 패스*


#### 문자 타입
- 러스트의 `char`는 가장 기본적인 알파벳 타입
```rust
let c = 'z';
let z: char = 'ℤ'; // 명시적인 타입 어노테이션
let heart_eyed_cat = '😻';
```
- `주의`: 문자열은 큰따옴표(`""`) 사용, `char` 타입은 작은 따옴표(`''`)를 사용
- 러스트의 `char` 타입은 4바이트 크기
- 유니코드 스칼라 값을 표현
  - 이는 ASCII보다 훨씬 더 많은 값을 표현할 수 있다는 의미
  - `Q` 왜 4바이트일까?
    -  [Why is the size of `char` 4 bytes in Rust? - stackoverflow](https://stackoverflow.com/questions/36381001/why-is-the-size-of-char-4-bytes-in-rust)
- 유니코드 스칼라 값의 범위는 `U+0000` ~ `U+D7FF`, 그리고 `U+E000` ~ `U+10FFFF`

### 복합 타입
*복합 타입(compound type)* 은 여러 값을 하나의 타입으로 묶을 수 있는 타입을 의미합니다. 러스트에는 튜플(tuple)과 배열(array) 두 가지 기본 복합 타입이 있습니다.

#### 튜플 타입
- 튜플은 다양한 타입의 여러 값을 묶어 하나의 복합 타입으로 만드는 일반적인 방법
- 고정된 길이를 가짐
  - 한번 선언되면 그 크기를 늘리거나 줄일 수 없음
- 괄호 안에 쉼표로 구분하여 값들의 목록을 작성하면 튜플을 만들 수 있음
- 튜플 내의 각 위치는 타입을 갖고, 이 튜플 내의 타입들은 서로 달라도 됨
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

// 타입을 명시하지 않을 수도 있음
let tup = (500, 6.4, 1);

let (x, y, z) = tup;

println!("The value of y is: {y}");
```
- 위 예제처럼 구조해체(destructuring) 방식을 사용할 수 있음
  
마침표(.) 뒤에 접근하고자 하는 값의 인덱스를 쓰는 방식을 통해 튜플 요소에 접근하는 방법도 있습니다.
```rust
let x: (i32, f64, u8) = (500, 6.4, 1);

let five_hundred = x.0; // 500

let six_point_four = x.1; // 6.4

let one = x.2;  // 1
```

- 위 처럼 각 요소에 접근할 수 있음
- 아무 값도 없는 튜플은 *유닛(unit)* 이라는 특별한 이름을 가짐
  - 이 값과 타입은 모두 `()`로 작성되고 빈 값이나 비어있는 반환 타입을 나타냄
  - 표현식이 어떤한 값도 반환하지 않는다면 암묵적으로 유닛 값을 반환하게 됨

#### 배열 타입
튜플과 달리 배열의 모든 요소는 모두 같은 타입이여야 합니다. 몇몇 다른 언어들과는 달리 러스트의 배열은 고정된 길이를 가집니다.  
대괄호 안에 쉼표로 구분한 값들을 나열해서 배열을 만들 수 있습니다.
```rust
let a = [1, 2, 3, 4, 5];
```

- 힙보다는 스택에 데이터를 할당하고 싶을 때나 항상 고정된 개수의 요소로 이루어진 경우라면 배열이 유용함
- 배열은 벡터 타입처럼 유연하지는 않음
- 벡터는 표준 라이브러리가 제공하는 배열과 유사한 컬렉션 타입
  - 크기를 늘리거나 줄일 수 있음
  - 배열을 이용할지 혹은 벡터를 이용할지 잘 모르겠는 경우 보통은 벡터를 사용하게 될것
    - 유연하기 때문에
    - 그러나 요소의 개수가 바뀔 필요가 없다는 것을 알고 있을 때라면 배열이 더 유용함

다음과 같이 대괄호 안에 요소의 타입을 쓰고 세미콜론을 쓴 뒤 요소의 개수를 적는 식으로 배열의 타입을 작성할 수도 있습니다.
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
- `i32` 타입의 요소가 5

아래와 같이 배열을 초기화하는 방법도 있습니다.  
채워질 요소와 길이를 명시합니다.
```rust
let a = [3; 5];
// let a = [3, 3, 3, 3, 3]; 과 동일
```

##### 배열 요소에 접근하기
- 배열은 스택에 할당될 수 있는 계산 가능한 고정된 크기의 단일 메모리 뭉치
```rust
let a = [1, 2, 3, 4, 5];

let first = a[0];
let second = a[1];
```

##### 유효하지 않은 배열 요소에 대한 접근
러스트에서는 유효하지 않는 배열 요소에 접근하는 경우 아래와 같은 출력을 볼 수 있습니다.
```shell
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

프로그램은 인덱스 연산에서 잘못된 값을 사용한 시점에서 *런타임 에러*를 발생 시킵니다. 러스트는 사용자가 입력한 인덱스가 배열 길이보다 작은지 검사할 것입니다. 인덱스가 배열 길이보다 크거나 같은 경우 러스트는 패닉(panic)을 일으킵니다. 
  
런타임에서 이러한 이슈가 발생하는 경우 러스트의 안전성 원칙이 동작하는 하나의 예입니다. 많은 저수준 언어들에서는 이러한 검사가 이루어지지 않고 유효하지 않은 메모리에 접근이 가능합니다. 러스트는 이런 메모리 접근을 허용하고 계속 실행하는 대신 즉시 실행을 종료함으로써 이런 종류의 에러로부터 사용자를 보호합니다. 러스트의 에러 처리 및 패닉을 일키지 않으면서 유효하지 않는 메모리 접근도 허용하지 않는 읽기 쉽고 안전한 코드를 작성하는 방법에 대해서는 9장에서 더 자세히 다뤄봅니다.