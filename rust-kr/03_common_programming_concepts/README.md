# 일반적인 프로그래밍 개념

이 장은 러스트 고유의 개념은 없지만, 러스트의 맥락에서 논의하고 이러한 개념 사용과 관련된 규칙을 설명합니다.  
  
특히 변수, 기본 타입, 함수, 주석 그리고 제어 흐름에 대해서 알아봅니다.

## 변수와 가변성
- **변수는 기본적으로 불변(immutable)**
  - 러스트가 제공하는 안정성과 쉬운 동시성을 활용하는 방식으로 코드를 작성할 수 있도록 하는 넛지(nudge, 슬며시 선택을 유도하기) 중 하나
  - 그렇지만, 필요하다면 가변(mutable)으로 만들 수도 있음
- 변수가 불변일 때, 그 값이 변수에 대입되면 그 값은 바꿀 수 없음

실제 코드로 어떻게 동작하는지 확인해봅니다.
```shell
$ cargo new variables
```
- `variables`라는 이름의 프로젝트를 생성

main.rs와 아래와 같이 작성합니다.
```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

실행해봅니다.
```shell
$ cargo run
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` (bin "variables") due to previous error
```
- 컴파일러는 에러가 있다는 것을 알려줌
  - 메세지의 내용을 보면 `불변 변수 x에 두 번 값을 할당할 수 없다`라고 합니다.  
- 불변으로 지정한 값을 변경하려고 하는 상황이 버그로 이어질 수 있기 때문에, 컴팡일 타임 에러가 발생하는 것은 중요함
- 변수의 쉬운 변경으로 인해 같은 값을 바라보는 서로 다른 일에 영향을 줄수 있음 
  - 이는 버그를 발생 
  - 러스트 컴파일러는 값이 바뀌지 않을 것이라고 지정하면 실제로 그렇도록 보증 
    - 이 규칙을 통해 값이 실제로 어디서 변경될 것인지 추적하지 않아도 됨
- 때때로 가변성은 유용하기도 하며, 코드 작성을 더 편하게 함
  - 가변성을 가진 변수를 만들기 위해서는 `mut`을 붙여서 가변으로 만들 수 있음

main.rs를 아래와 같이 수정합니다.
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```

그럼 다음 출력을 볼 수 있습니다.
```shell
$ cargo run
Compiling variables v0.1.0 (/Users/xtring/Study/rust-study/rust-kr/03_common_programming_concepts/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

이렇게 `mut`를 사용해 변수의 값을 변경할 수 있습니다. 

### 상수
- *상수(constant)* 는 불변 변수와 비슷한데, 어떤 변수에 묶여 있는 값이고 값을 바꾸는 것이 허용되지 않지만, 변수와는 약간 다른 점들이 있음
- 상수는 `mut`와 함께 사용할 수 없음
  - 상수는 기본적으로 불변인 것이 아니고, **항상 불변**
  - 상수는 `let`이 아닌 `const` 키워드로 선언
  - *타입이 반드시 명시되어야 함*
  - 상수는 반드시 런타임에서만 계산할 수 있는 값의 결과가 아니라 *상수 표현식으로만 설정할 수 있음*
  - 예를 들어 `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`인 상수는 이와 같이 `대문자`로 표현되면 단어 사이에는 `_`를 사용
    - 컴파일러는 컴파일 타임에 *제한된 연산*을 사용하여 해당 상수를 10,800으로 계산하고 고정해둡니다.
- 이렇게 특정한 의미가 있는 값에 의미가 있는 이름을 붙임으로서 미래의 코드 관리자에게 그 값의 의미를 전달하는데 유용함
  - 또, 나중에 업데이트될 하드코딩된 값을 단 한 군데에서 변경할 수 있게 함

### 섀도잉
- 2장 추리게임 코드에서도 보았듯이, 새 변수를 이전 변수명과 같은 이름으로 선언하여 사용할 수 있음
  - 첫 번째 변수가 두 번째 변수에 의해 *가려졌다(shadowed)* 라고 표현하며, 이는 해당 변수의 이름을 사용할 때 컴파일러가 두 번째 변수를 바라보게 될 것임을 의미함
  - 아래 예제와 같이 똑같은 변수명과 `let` 키워드를 통해 반복적으로 shadowing 할 수 있음

main.rs
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }
    
    println!("The value of x is: {x}");
}
```

실행 후 결과는 아래와 같습니다.
```shell
$ cargo run
Compiling variables v0.1.0 (/Users/xtring/Study/rust-study/rust-kr/03_common_programming_concepts/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/variables`   
The value of x in the inner scope is: 12
The value of x is: 6
```
  
- 섀도잉은 변수를 `mut`로 표시하는 것과 다름
  - 실수로 `let` 키워드 없이 변수에 값을 재할당하려고 하면 컴파일 타임 에러가 발생하기 때문
  - `let`을 사용하며느 값을 변형하면서 변형이 완료된 후에는 불변으로 유지할 수 있음
  - 섀도잉은 다시금 `let` 키워드를 사용하여 새로운 변수를 만드는 것이기 때문에 같은 변수명으로 다른 타입의 값을 저장할 수 있음
```rust
// ok - 타입이 변경되어도 가능
let spaces = "   ";
let spaces = spaces.len();

// nop - 변경가능한 변수에 다른 타입의 값을 재할당하려고 하기 때문에 컴파일 에러 발생
let mut spaces = "   ";
spaces = spaces.len();
```

## 데이터 타입
> 러스트의 모든 값은 특정한 타입을 가지며, 이는 러스트가 해당 데이터로 작업하는 방법을 알 수 있도록 어떤 종류의 데이터가 지정되고 있는지 알려줍니다. 여기서는 타입을 스칼라 타입과 복합 타입, 두 가지 부분 집합으로 나누어 보겠습니다.
  
- 러스트는 *정적타입(statically typed)* 언어
  - 모든 변수의 타입이 컴파일 시점에 반드시 정해져 있어야 한다는 의미
    - 여러 가지 타입이 가능한 경우 타입을 명시해야함
      - `let guess: u32 = "42".parse().expect("Not a number!");`: String 타입의 "42"를 guess 변수에 다시 32bits 정수 타입으로 할당하는 경우
        - 타입을 지정하지 않으면 컴파일시 에러가 발생함

### 스칼라 타입
- *스칼라(scalar)* 타입은 하나의 값을 표현
  - 러스트는 정수, 부동 소수점 숫자, 불린(boolean), 문자 4가지 스칼라 타입을 갖고 있음

#### 정수형
- *정수형(integer type)* 은 소수점이 없는 숫자
  - 먼저 살펴본 `u32` 타입의 경우 부호가 없는 32비트 변수를 의미함(부호가 있는 타입: `i`)

|길이	|부호 있음 (signed)	|부호 없음 (unsigned)|
|--|--|--|
|8-bit	|i8	|u8
|16-bit	|i16	|u16
|32-bit	|i32	|u32
|64-bit	|i64	|u64
|128-bit	|i128	|u128
|arch	|isize	|usize

- 각각의 크기별 타입은 부호 있는(signed) 혹은 부호 없는(unsigned) 타입이며 명시된 크기를 가짐
- 부호 유무의 의미는 해당 타입이 음수를 다룰 수 있는지를 의미함
  - 부호 있는 숫자는 `2의 보수` 형태를 사용하여 저장
- 각 부호 있는 타입 변수는 `-(2^(n-1))` ~ `2^(n-1)-1`의 값을 저장할 수 있음
  - `n`은 사용되는 타입의 비트 수를 의미함
  - `u8` 타입은 0에서 2^8 - 1 다시 말해, 0에서 255까지의 값을 저장할 수 있음
- `isize`와 `usize` 타입은 사용자의 프로그램이 동작하는 컴퓨터 환경에 따라 결정됨
  - 위 표에서는 `arch`라고 적시됨
  - 64-bit라면 64비트, 32-bit라면 32비트 기반으로 설정
  

정수형 리터럴은 아래와 같은 형태로 작성 가능
- 여러 숫자 타입이 될 수 있는 숫자 리터럴에는 `57u8`과 같은 타입 접미사를 사용하여 타입을 지정 가능

|숫자 리터럴	|예 |
|--|--|
|Decimal	|98_222|
|Hex	|0xff|
|Octal	|0o77|
|Binary	|0b1111_0000|
|Byte (u8 only)	|b'A'|

> 어떤 타입의 정수를 사용해야 하는지는 어떻게 알아낼까요?  
  
  확실히 정해진 경우가 아니라면 러스트의 기본값인 `i32`가 일반적으로 좋은 시작 지점이 됩니다. `isize`나 `usize`는 주로 어떤 컬렉션 종류의 인덱스에 사용됩니다.

> 정수 오버플로우  
여러분이 0과 255 사이의 값을 담을 수 있는 u8 타입의 변수를 갖고 있다고 해봅시다. 만약에 이 변수에 256처럼 범위 밖의 값으로 변경하려고 하면 정수 오버플로우 (integer overflow) 가 일어나는데, 이는 둘 중 한 가지 동작을 일으킵니다. 코드를 디버그 모드에서 컴파일하는 경우, 러스트는 런타임에 정수 오버플로우가 발생했을 때 패닉 (panic) 을 발생시키는 검사를 포함시킵니다. 러스트에서는 에러가 발생하면서 프로그램이 종료되는 경우 패닉이라는 용어를 사용합니다; 9장의 ‘panic!으로 복구 불가능한 에러 처리하기’절에서 패닉에 대해 좀 더 자세히 다루겠습니다.  
--release 플래그를 사용하여 코드를 릴리즈 모드로 컴파일하는 경우에는 패닉을 발생시키는 정수 오버플로우 검사를 실행파일에 포함시키지 않습니다. 대신 오버플로우가 발생하면 러스트는 2의 보수 감싸기 (two's complement wrapping) 을 수행합니다. 짧게 설명하자면, 해당 타입이 가질 수 있는 최댓값보다 더 큰 값은 허용되는 최솟값으로 ‘돌아갑니다 (wrap around)’. u8의 경우 256은 0이, 257은 1이 되는 식입니다. 프로그램은 패닉을 발생시키지 않으나, 해당 변수는 아마도 여러분이 예상치 못했던 값을 갖게 될 겁니다. 정수 오버플로우의 감싸기 동작에 의존하는 것은 에러로 간주됩니다.  
명시적으로 오버플로우의 가능성을 다루기 위해서는 표준 라이브러리에서 기본 수치 타입에 대해 제공하는 아래 메서드 종류들을 사용할 수 있습니다:  
wrapping_add와 같은 wrapping_* 메서드로 감싸기 동작 실행하기
checked_* 메서드를 사용하여 오버플로우가 발생하면 None 값 반환하기
overflowing_* 메서드를 사용하여 값과 함께 오버플로우 발생이 있었는지를 알려주는 부울린 값 반환하기
saturating_* 메서드를 사용하여 값의 최대 혹은 최솟값 사이로 제한하기
  
#### 부동 소수점 타입
러스트의 *부동 소수점(floating-point) 숫자* 타입에는 두가지가 있습니다. 
- `f32`, `f64`
  - 기본 타입은 `f64`
    - 이뉴는 현대의 CPU 상에서 `f64`가 `f32`와 비슷한 속도를 내면서도 더 정밀하기 때문. 모든 부동 소수점 타입은 부호가 있음
```rust
let x = 2.0; // f64
let y: f32 = 3.0; // f32
```
- 부동 소수점 숫자는 IEEE-754 표준을 따름
- `f32` 타입은 1배수 정밀도(single-precision)인 부동 소수점
- `f64` 타입은 2배수 정밀도(double-precision)인 부동 소수점


#### 수치 연산
*다른 언어와 큰 차이없어 패스*


#### 부울린 타입
*다른 언어와 큰 차이없어 패스*


#### 문자 타입
- 러스트의 `char`는 가장 기본적인 알파벳 타입
```rust
let c = 'z';
let z: char = 'ℤ'; // 명시적인 타입 어노테이션
let heart_eyed_cat = '😻';
```
- `주의`: 문자열은 큰따옴표(`""`) 사용, `char` 타입은 작은 따옴표(`''`)를 사용
- 러스트의 `char` 타입은 4바이트 크기
- 유니코드 스칼라 값을 표현
  - 이는 ASCII보다 훨씬 더 많은 값을 표현할 수 있다는 의미
  - `Q` 왜 4바이트일까?
    -  [Why is the size of `char` 4 bytes in Rust? - stackoverflow](https://stackoverflow.com/questions/36381001/why-is-the-size-of-char-4-bytes-in-rust)
- 유니코드 스칼라 값의 범위는 `U+0000` ~ `U+D7FF`, 그리고 `U+E000` ~ `U+10FFFF`

### 복합 타입
*복합 타입(compound type)* 은 여러 값을 하나의 타입으로 묶을 수 있는 타입을 의미합니다. 러스트에는 튜플(tuple)과 배열(array) 두 가지 기본 복합 타입이 있습니다.

#### 튜플 타입
- 튜플은 다양한 타입의 여러 값을 묶어 하나의 복합 타입으로 만드는 일반적인 방법
- 고정된 길이를 가짐
  - 한번 선언되면 그 크기를 늘리거나 줄일 수 없음
- 괄호 안에 쉼표로 구분하여 값들의 목록을 작성하면 튜플을 만들 수 있음
- 튜플 내의 각 위치는 타입을 갖고, 이 튜플 내의 타입들은 서로 달라도 됨
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

// 타입을 명시하지 않을 수도 있음
let tup = (500, 6.4, 1);

let (x, y, z) = tup;

println!("The value of y is: {y}");
```
- 위 예제처럼 구조해체(destructuring) 방식을 사용할 수 있음
  
마침표(.) 뒤에 접근하고자 하는 값의 인덱스를 쓰는 방식을 통해 튜플 요소에 접근하는 방법도 있습니다.
```rust
let x: (i32, f64, u8) = (500, 6.4, 1);

let five_hundred = x.0; // 500

let six_point_four = x.1; // 6.4

let one = x.2;  // 1
```

- 위 처럼 각 요소에 접근할 수 있음
- 아무 값도 없는 튜플은 *유닛(unit)* 이라는 특별한 이름을 가짐
  - 이 값과 타입은 모두 `()`로 작성되고 빈 값이나 비어있는 반환 타입을 나타냄
  - 표현식이 어떤한 값도 반환하지 않는다면 암묵적으로 유닛 값을 반환하게 됨

#### 배열 타입
튜플과 달리 배열의 모든 요소는 모두 같은 타입이여야 합니다. 몇몇 다른 언어들과는 달리 러스트의 배열은 고정된 길이를 가집니다.  
대괄호 안에 쉼표로 구분한 값들을 나열해서 배열을 만들 수 있습니다.
```rust
let a = [1, 2, 3, 4, 5];
```

- 힙보다는 스택에 데이터를 할당하고 싶을 때나 항상 고정된 개수의 요소로 이루어진 경우라면 배열이 유용함
- 배열은 벡터 타입처럼 유연하지는 않음
- 벡터는 표준 라이브러리가 제공하는 배열과 유사한 컬렉션 타입
  - 크기를 늘리거나 줄일 수 있음
  - 배열을 이용할지 혹은 벡터를 이용할지 잘 모르겠는 경우 보통은 벡터를 사용하게 될것
    - 유연하기 때문에
    - 그러나 요소의 개수가 바뀔 필요가 없다는 것을 알고 있을 때라면 배열이 더 유용함

다음과 같이 대괄호 안에 요소의 타입을 쓰고 세미콜론을 쓴 뒤 요소의 개수를 적는 식으로 배열의 타입을 작성할 수도 있습니다.
```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
- `i32` 타입의 요소가 5

아래와 같이 배열을 초기화하는 방법도 있습니다.  
채워질 요소와 길이를 명시합니다.
```rust
let a = [3; 5];
// let a = [3, 3, 3, 3, 3]; 과 동일
```

##### 배열 요소에 접근하기
- 배열은 스택에 할당될 수 있는 계산 가능한 고정된 크기의 단일 메모리 뭉치
```rust
let a = [1, 2, 3, 4, 5];

let first = a[0];
let second = a[1];
```

##### 유효하지 않은 배열 요소에 대한 접근
러스트에서는 유효하지 않는 배열 요소에 접근하는 경우 아래와 같은 출력을 볼 수 있습니다.
```shell
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

프로그램은 인덱스 연산에서 잘못된 값을 사용한 시점에서 *런타임 에러*를 발생 시킵니다. 러스트는 사용자가 입력한 인덱스가 배열 길이보다 작은지 검사할 것입니다. 인덱스가 배열 길이보다 크거나 같은 경우 러스트는 패닉(panic)을 일으킵니다. 
  
런타임에서 이러한 이슈가 발생하는 경우 러스트의 안전성 원칙이 동작하는 하나의 예입니다. 많은 저수준 언어들에서는 이러한 검사가 이루어지지 않고 유효하지 않은 메모리에 접근이 가능합니다. 러스트는 이런 메모리 접근을 허용하고 계속 실행하는 대신 즉시 실행을 종료함으로써 이런 종류의 에러로부터 사용자를 보호합니다. 러스트의 에러 처리 및 패닉을 일키지 않으면서 유효하지 않는 메모리 접근도 허용하지 않는 읽기 쉽고 안전한 코드를 작성하는 방법에 대해서는 9장에서 더 자세히 다뤄봅니다.


## 함수

- 러스트 코드는 함수나 변수 이름을 위한 관례로 *스네이크 케이스(snake case) 방식* 을 이용
  - 모든 글자를 소문자로 쓰고 밑줄(underscore)로 단어를 구분하는 방식
- 함수 정의 시 `fn` 뒤에 함수 이름과 괄호를 붙여서 함수를 정의
- 함수의 중괄호를 통해 함수 본문의 시작과 끝을 컴파일러에게 알려줌
```rust
fn make_function() {
  // ...
}
```
- 러스트는 함수의 위치를 고려하지 않으며, 호출하는 쪽에서 볼 수 있는 스코프 어딘가에만 정의되어 있으면 됨


### 매개변수
- 함수는 매개변수(parameter)를 갖도록 정의될 수 있음
  - 함수 시그니처(function signiture)의 일부인 특별한 변수
    - 함수 시그니처에서는 각 매개변수의 타입을 반드시 선언해야함
  - 매개변수를 통해 구체적인 값을 전달할 수 있음
    - 이런 구체적인 값을 인수(argument)라고 부름
  - 함수 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때 의도한 타입을 컴파일러가 추측하지 않아도 되게 됩
    - 컴파일러는 또한 함수가 기대한 타입이 무엇인지 알고 있으면 더욱 유용한 에러 메시지를 제공할 수 있음
  - 여러개의 매개 변수를 가지는 겨우 쉼표 기호로 매개변수 정의를 구분

### 구문과 표현식
- 함수 본문은 필요에 따라 표현식(expression)으로 끝나는 구문(statement)의 나열로 구성됨
- 러스트는 표현식 기반의 언어
  - 구문과 표현식의 구분
    - 구문: 어떤 동작을 수행하고 값을 반환하지 않는 명령
    - 표현식: 결괏값을 평가
    - ```rust
      fn main() {
        let y = 6;
      }
      ```
    - `let` 키워드로 변수를 만들고 값을 할당하는 것은 구문
      - `let y = 6;`은 구문
    - 함수 정의도 구문
    - 구문은 값을 반환하지 않음, 따라서 아래와 같이 `let` 구문을 다른 변수에 할당하려고하면 에러가 발생
      - ```rust
        fn main() {
          let x = (let y = 6);
        }
        ```
      - `let y = 6` 구문은 값을 반환하지 않으므로 `x`에 바인딩시키지 않음
  - 러스트 코드의 표현식 형태
    - 어떤 값을 평가한다.
    - ```rust
      fn main() {
        let y = {
          let x = 3;
          x + 1
        };
        println!("The value of y is: {y}"); // The value of y is: 4
      }
      ```
      - `x + 1` 줄의 마지막이 세미콜론으로 끝나지 않은 점을 주목!
      - 표현식은 종결을 나타내는 세미콜론을 쓰지 않음
      - 만약 표현식 끝에 세미콜론을 추가하면, 표현식은 구문으로 변경되고 값을 반환하지 않게 됨

### 반환 값을 갖는 함수

- 함수는 호출한 코드에 값을 반환할 수 있음
- 반환되는 값의 타입은 화살표(->) 뒤에 선언
- 러스트에서 함수의 반환 값은 함수 본문의 마지막 표현식의 값과 동일함
- `return` 키워드와 값을 지정하여 함수로부터 일찍 값을 반환할 수 있지만, 대부분의 함수들은 암묵적으로 마지막 표현식 값을 반환
```rust
fn five() -> i32 {
    5
}

fn main() {
  let x = five();
  
  println!("The value of x is: {x}");
}
```
- 만약 세미콜론이 추가되어 표현식이 구문으로 변경되면 아래와 같은 에러가 발생합니다.
- ```rust
  fn main() {
    let x = plus_one(5);
  
    println!("The value of x is: {x}");
  }
  
  fn plus_one(x: i32) -> i32 {
    x + 1;
  }
  ```
  - ```shell
    $ cargo run
    error[E0308]: mismatched types
    ```
    

## 주석
러스트의 주석은 아래와 같이 사용합니다.
```rust
// hello, world!
```
  
## 제어 흐름문

### if 표현식
```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
- 조건식은 반드시 `bool` 타입
  - 조건식이 `bool` 타입이 아니라면 에러가 발생
```rust
// 에러 발생
fn main() {
  let number = 3;
  
  if number {   // if 의 조건식은 bool 타입이어야 합니다.
    println!("number was three");
  }
}
```
- 러스트는 Ruby나 JS와 같이 if 문에에서 `bool` 타입 여부를 형변환하여 체크하지 않음
- if 문에는 항상 명시적으로 `bool` 타입임을 확인해야함

#### else if로 여러 조건 다루기
- 조건문이 `bool` 타입을 통해 평가되는 것만 빼면 기존 언어들과 동일하게 사용됨
- `else if` 표현식을 너무 많이 사용하는 경우 코드가 복잡해질 수 있으므로, 표현식이 두 개 이상이면 코드를 리펙터링하는 것이 좋음
- [6장](https://rust-kr.github.io/doc.rust-kr.org/ch06-02-match.html)에서는 이런 경우 적합한 `match`라는 러스트의 강력한 분기 구조에 대해 설명함


#### let 구문에서 if 사용하기
- `if`는 표현식이기 때문에 변수에 결과를 할당하기 위하여 `let` 구문의 우변에 사용할 수 있음
```rust
let condition = true;
let number = if condition { 5 } else { 6 };

println!("The value of number is: {number}");
```
- number 변수에는 if 표현식의 결과가 바인딩됨
  - 5
- 그렇기 때문에 number에 바인딩 될 결과값의 타입은 동일해야함
  - 5, 6은 같은 `i32` 타입
  - 타입이 다른 경우 컴파일 에러가 발생
    
### 반복문을 이용한 반복
- 러스트는 몇 가지 *반복문(loop)* 을 제공
  - 루프 본문의 시작부터 끝까지 수행한 뒤 처음부터 수행을 반복
  - `loop`, `while`, `for` 세가지 반복문이 있음

#### loop로 코드 반복하기
- `loop` 키워드는 명시적으로 알려주기 전까지, 영원히 코드 블록을 반복 수행하도록 함
```rust
fn main() {
  loop {
    println!("again!");
  }
}
```
- 강제로 정지(ctrl + c)하기 전까지 실행됨
- 루프에서 벗어나는 방법
  - `break`를 사용하면 `loop`를 탈출
  - `continue`를 사용하면 실행하던 `loop` 본문 중 `continue`만난 곳에서 다시 처음부터 실행

#### 반복문에서 값 반환하기
- `loop`의 용례 중 하나는 어떤 스레드가 실행 완료되었는지 검사하는 등 실패할지도 모르는 연산을 재시도할 때입니다.
  - 여기서 해당 연산(loop 연산)의 결과를 이후 코드에 전달하고 싶다면 `break` 표현식 뒤에 반환하고자 하는 값을 넣으면 됨
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```
- 이 예제에서 보아야할 키-포인트는 두가지
  - `loop`가 표현식으로 사용됨
  - `loop` 문의 탈출이 `break` 표현식으로 이루어짐 그리고 `break` 뒤에 반환값을 넣어줌!

#### 루프 라벨로 여러 반복문 사이에 모호함 없애기
만일 루프가 안에 루프가 있다면, `break`와 `continue`는 해당 지점의 바로 바깥쪽 루프에 적용됩니다. 루프에 *루프 라벨(loop label)* 을 추가로 명시하면 `break`나 `continue`와 함께 이 키워드들이 바로 바깥쪽 루프 대신 라벨이 적히 특정한 루프로 이동할 수 있도록 할 수 있습니다.  
**루프 라벨은 반드시 작은 따옴표로 시작해야합니다.** 아래 예제를 살펴봅니다.
```rust
fn main() {
  let mut count = 0;
  'counting_up: loop {
    println!("count = {count}");
    let mut remaining = 10;

    loop {
      println!("remaining = {remaining}");
      if remaining == 9 {
        break;
      }
      if count == 2 {
        break 'counting_up;
      }
      remaining -= 1;
    }

    count += 1;
  }
  println!("End count = {count}");
}
```
- 바깥쪽 루프는 `'counting_up`이라는 라벨이 붙어있고, 안쪽 loop의 조건에 해당하면 다시 `'counting_up` 루프로 이동하게 됩니다.
- 안쪽 루프의 `break`는 안쪽 루프만을 벗어납니다.

#### while을 이용한 조건 반복문
- `while`은 조건문이 `true`가 아니게 될 때 프로그램은 `break`를 호출하여 반복을 종료
```rust
fn main() {
  let mut number = 3;
  while number != 0 {
    println!("{number}!");

    number -= 1;
  }

  println!("LIFTOFF!!!");
}
```
- `while` 문은 `loop`, `if`, `else` 및 `break`를 사용할 때 필요하게 될 많은 중첩 구조를 제거하고 코드를 더 깔끔하게 만듦

#### for를 이용한 컬렉션에 대한 반복문
- `while`를 사용하여 배열과 같은 컬렉션의 각 요소에 대한 반복문을 작성할 수 있음
  - 이 방식은 배열의 마지막 인덱스에 도달할 때까지 반복
  - 이런 접근 방식은 에러가 발생하기 쉬움
    - 즉 인덱스의 길이가 부정확하면 패닉을 발생시키는 프로그램이 될 수 있음
    - 예를 들어 a 배열이 네 개의 쇼로를 갖도록 정의한 부분을 변경했는데 `while index < 4`의 조건문을 고치는 걸 잊어버린다면 코드는 패닉을 일으킨다.
      - 또한, 컴파일러가 루프의 매 반복 회차마다 인덱스가 범위 안에 있는지에 대한 조건문 검사를 수행하는 코드를 붙이기 때문에 느려진다.

이것에 대한 대안으로 `for` 반복문을 사용하여 컬렉션의 각 아이템에 대하여 임의의 코드를 수행시킬 수 있습니다.
```rust
fn main() {
  let a = [10, 20, 30, 40, 50];

  for element in a {
    println!("the value is: {element}");
  }
}
```
- `for` 문을 사용하면 코드의 안전성이 강화되고 배열의 끝을 넘어서거나 끝까지 가지 못해서 몇 개의 아이템을 놓쳐서 발생할 수도 있는 버그의 가능성을 제거합니다.
  - 배열 내 값의 개수가 변경되더라도 수정해야 할 다른 코드를 기억해둘 필요가 없음
- 러스트에서 가장 흔하게 사용되는 반복문 구성요소
  - `while` 보다 많이 사용됨
- 표준 라이브러리가 제공하는 `Range` 타입을 이용하면 특정 횟수만큼의 반복문을 구현할 수 있음
  - 어떤 숫자에서 시작하여 다른 숫자 종료 전까지의 모든 숫자를 차례로 생성해줌

추가 예시로 `for` 반복문을 이용한 카운트 다운 구현은 아래 처럼 생겼습니다.
```rust
fn main() {
  for number in (1..4).rev() {
    println!("{number}!");
  }
  println!("LIFTOFF!!!");
}
```
