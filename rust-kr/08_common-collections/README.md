# 8. 일반적인 컬렉션
러스트의 표준 라이브러리에는 *컬렉션(collection)* 이라 불리는 유용한 데이터 구조들이 여러 개 포함되어 있다. 다른 데이터 타입과 달리 컬렉션은 다수의 값을 담을 수 있다. 내장된 배열(build-in array)이나 튜플 타입과는 달리, 이 컬렉션들이 가리키고 있는 데이터들은 힙에 저장되는데, 이는 즉 데이터의 양이 컴파일 타임에 결정되지 않아도 되며 프로그램 실행 중에 늘어나거나 줄어들 수 있다는 의미이다.(동적이다) 각 컬렉션 종류는 서로 다른 크기와 비용을 가지고 있으며, 상황에 따라 적절한 컬렉션을 선택해서 사용해야 한다.  

- 벡터(vector): 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 함
- 문자열(string): 문자(character)의 모음, `String` 타입
- 해시맵(hash map): 어떤 값을 특정한 키와 연관지어 주도록 해줌, 이는 맵(map)이라 일컫는 좀 더 일반적인 데이터 구조의 특정한 구현 형태

  
## 벡터에 여러 값의 목록 저장하기
- `Vec<T>`
  - 벡터를 사용하면 메모리에서 모든 값을 서로 이웃하도록 배치하는 단일 데이터 구조에 하나 이상의 값을 저장할 수 있음
  - 벡터는 같은 타입의 값만을 저장할 수 있음  

### 백터 만들기
- 비어있는 새 백터를 만들기 위해서는 `Vec:new` 함수를 호출함
```rust
// i32 타입의 값을 가질 수 있는 비어있는 새 벡터 생성
let v: Vec<i32> = Vec::new();
```
- `Vec<i32>`에는 타입 명시가 되어 있음
  - 변수 `v`에는 어떠한 값도 집어넣지 않았기 때문에, 러스트는 저장하고자 하는 요소가 어떤 타입인지 모름
  - 따라서 제네릭(generic)을 이용해 해당 변수에 어떤 타입의 값을 가질지 알려주는 것  
  

편의상 `vec!` 매크로를 사용할 수 있음
```rust
// 값을 저장하고 있는 새로운 벡터 생성
let v = vec![1, 2, 3];
```
- 기본 정수형은 `i32`이기 때문에 `Vec[i32]`를 생성함
  - 추가적인 타입 추론은 없어도 된다~

### 백터 업데이트하기
벡터에 값을 추가하는 방법은 `push` 메소드를 사용한다.
```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```
- 값을 변경하려면 `mut` 키워드를 추가하여 가변 변수라는 것을 명시해야함


### 백터 요소 읽기
벡터에 저장된 값을 참조하는 방법  
- 인덱싱
- `get` 메서드
```rust
// 인덱스 혹은 get 메서드를 통해 벡터 내 아이템에 접근하기
let v = vec![1, 2, 3, 4, 5];

let third: &32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
  Some(third) => println!("The third element is {third}"),
  None => println!("There is no third element."),
}
```
**주의할 점!**  
- 벡터의 인덱스는 0부터 시작하므로, 세 번째 값을 얻어오기 위해서는 인덱스 값 `2`를 사용
- `&`와 `[]`를 사용하면 인덱스 값에 위치한 요소의 참조자를 얻을 수 있음
- `get` 함수에 인덱스를 매개변수로 넘기면, `match`를 통해 처리할 수 있는`Option<&T>`를 얻게 됨  
  
러스트가 벡터 요소를 참조하는 방법을 두 가지 제공하는 이유는 벡터에 없는 인덱스 값을 사용하고자 했을 때 프로그램이 어떻게 동작할 것인지 선택하기 위함이다. 예를 들어 값이 존재하지 않는 인덱스에 그냥 접근하는 경우(단순히 인덱스로만 접근하는 경우) 러스트 프로그램은 죽게 된다.  
  
**`get` 함수에 벡터 범위를 벗어난 인덱스가 주어지면 패닉 없이 `None`이 반환된다.** 일반적인 상황에서 벡터의 범위 밖에 있는 요소에 접근하는 일이 종종 발생할 수 있다면 이 방법을 사용합니다.  
  
같은 스코프에서는 가변 참조자와 불변 참조자를 가질 수 없다는 규칙을 상기해야한다. 이 규칙은 아래 예제에서도 적용되며 벡터의 첫 번째 요소에 대한 불변 참조자를 얻은 뒤 벡터의 끝에 요소를 추가하는 시도를 한다. 함수 끝에서 해당 요소에 대한 참조까지 시도한다면 이 프로그램은 동작하지 않을 것이다.
```rust
// 아이템의 참조자를 가지고 있는 상태에서 백터에 새로운 요소 추가 시도하기(동작하지 않음)
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```
```shell
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
```
> 벡터는 모든 요소가 서로 붙어서 메모리에 저장됩니다. 그리고 새로운 요소를 벡터 끝에 추가할 경우, 현재 벡터 메모리 위치에 새로운 요소를 추가할 공간이 없다면, 다른 넉넉한 곳에 메모리를 새로 할당하고 기존 요소를 새로 할당한 공간에 복사합니다. 이 경우, 기존 요소의 참조자는 해제된 메모리를 가리키게 되기 때문에, 이러한 상황을 대여 규칙으로 막아둔 것이죠.  

  
### 벡터 값에 대해 반복하기
벡터 내 값에 차례대로 접근하기 위해서는 `for` 루프를 사용하여 접근할 수 있다.
```rust
// for 루프로 벡터의 요소들에 대해 반복하여 각 요소를 출력하기
let v = vec![100, 32, 57];
for i in &v {
  println!("{i}");
}
``` 
  

모든 요소를 변경하기 위해서는 가변 벡터의 각 요소에 대한 가변 참조자로 반복 작업을 할 수 있다.
```rust
// 벡터의 요소에 대한 가변 참조자로 반복하기
let mut v = vec![100, 32, 57];
for i in &mut v {
  *i += 50;
}
```
- 가변 참조가 가리키는 값을 수정하려면, `+=` 연산자를 쓰기 전에 `*`역참조 연산자로 `i`의 값을 얻어야 한다.  
- `for` 루프 본문에서 아이템을 추가하거나 지우는 시도를 했다면 컴파일 에러가 발생함

### 열거형을 이용해 여러 타입 저장하기
벡터는 같은 타입을 가진 값들만 저장할 수 있다. 이는 불편할 수 있다; 다른 타입의 아이템들에 대한 리스트를 저장해야하는 상황도 분명 존재한다. 열거형의 배리언트는 같은 열거형 타입 내에 정의 되므로, 벡터 내에 다른 타입의 값들을 저장할 필요가 있다면 열거형을 정의하여 사용할 수 있다!
```rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
```
- 다양한 타입의 열거형을 담을 수 있음
- 러스트가 컴파일 타임에 벡터 내에 저장될 타입이 무엇인지 알아야 하는 이유는 각 요소를 저장하기 위해 얼마만큼의 힘 메모리가 필요한지 알아야 하기 때문임
  - 이 벡터가 담을 수 있는 타입을 명시적으로 보여줘야함
  - 만일 러스트가 어떤한 타입이든 담을 수 있는 벡터를 허용한다면 벡터의 각 요소마다 수행되는 연산에 대해 하나 혹은 그 이상의 타입이 에러를 발생시킬 수도 있다. 
  - 열거형과 `match` 표현식을 사용한다는 것은 러스트가 컴파일 타임에 가능한 모든 경우를 처리함을 보장해 준다는 뜻
  
런타임에 프로그램이 벡터에 저장할 모든 타입 집합을 알지 못하면 열거형을 이용한 방식은 사용할 수 없다. 대신 트레이트 객체(trait object)를 이용할 수 있다.(17장에서 다룸)

### 벡터가 버려지면 벡터의 요소도 버려진다
`struct`와 마찬가지로, 벡터는 스코프를 벗어날 때 해제된다.
```rust
// 벡터와 요소들이 버려지는 위치를 표시
{
  let v = vec![1, 2, 3, 4];
  // v를 가지고 작업함
} // <- 여기서 v가 스코프 밖으로 벗어나고 해제됨
```
- 벡터가 버려질 때 벡터의 내용물도 전부 버려짐
  - 벡터가 가지고 있던 정수들의 메모리도 정리
  - 대여 검사기는 벡터의 내용물에 대한 참조자의 사용이 해당 벡터가 유효할 때만 발생했는지 확인


