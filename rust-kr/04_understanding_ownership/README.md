# 소유권 이해하기
> 소유권(ownership)은 러스트에서 가장 독특한 기능이며 언어 전반에 깊은 영향을 끼칩니다. 소유권은 러스트가 가비지 컬렉터 없이 메모리 안정성을 보장하도록 해주므로, 소유권이 어떻게 동작하는지를 이해하는 것은 중요합니다. 이 장에서는 소유권을 비롯해 소유권과 관련된 대여(borrowing), 슬라이스(slice) 기능, 그리고 러스트에서 데이터를 메모리에 저장하는 방법에 대해 알아보겠습니다.


## 소유권이 뭔가요?
소유권은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음입니다.  
모든 프로그램은 작동하는 동안 컴퓨터의 메모리 사용 밥법을 관리해야 합니다.
- 몇몇 언어는 가비지 컬렉션으로 프로그램에서 더 이상 사용하지 않는 메모리를 정기적으로 찾고 정리하는 방식을 가짐
- 또 다른 언어는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는 방식을 택함
- 러스트는 이 두 방식이 아닌 제 3의 방식을 택함
  - **`소유권(ownership)`이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식**

### 스택 영역과 힙 영역
- 대부분의 프로그래밍 언어에서는 스택, 힙 영역을 주제로 고민할 필요가 많지 않음
  - 러스트와 같은 시스템 프로그래밍 언어에서는 값을 스택에 저장하느냐 힙에 저장하느냐의 차이가 프로그램의 동작 및 프로그램의 의사 결정에 큰 영향을 미침
- `스택`과 `힙` 둘 다 작성한 프로그램이 런타임에 이용하게 될 메모리 영역이라는 공통점을 가지지만, 구조는 각기 가름
  - `스택(stack)`: 값이 들어온 순서대로 저장, 역순으로 제거
    - 동작방식
      - 후입선출(LIFO; *last in, first out*)
      - 스택에 데이터를 추가하는 행위를 *푸시(push)* 라고 하며, 반대로 스택에서 데이터를 제거하는 행위는 *팝(pop)* 이라고 함
      - 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 함
    - **컴파일 타임에 크기를 알 수 없거나, 크기가 변경될 수 있는 데이터는 스택 대신 힙에 저장되어야함**
  - `힙(heap)`
    - 동작방식
      - 먼저 데이터를 힙에 넣을 때 먼저 저장할 공간이 있는지 운영체제에 물어봄
      - 메모리 할당자는 커다란 힙 영역 안에서 빈 지점을 찾고, 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 우리한테 반환
        - 이 과정을 *힙 공간 할당(allocating on the heap)*, 줄여서 *할당(allocation)* 이라고 함
          - 스택에 값을 푸시하는 것은 할당이라고 하지 않음
    - 포인터는 크기가 정해져 있어 스택에 저장할 수 있으나, 포인터가 가리키는 실제 데이터를 사용하고자 할 때는 포인터를 참조해 해당 포인터가 가리키는 위치로 이동하는 과정을 거침
- 스택 영역은 데이터에 접근하는 방식상 힙 영역보다 속도가 빠름
  - 메모리 할당자가 새로운 데이터를 저장할 공간을 찾을 필요 없이 항상 스택의 가장 위에 데이터를 저장하면 됨
  - 반면, 힙에 공간을 할당하는 직업은 좀 더 많은 작업을 요구함
    - 메모리 할당자가 데이터를 저장하기 충분한 공간을 먼저 찾고 다음 할당을 위한 준비를 위해 예약을 수행해야 하기 때문
- 힙 영역은 포인터가 가리키는 곳을 찾아가는 과정을 가지기 때문에 느림
  - 힙에 있는 데이터들은 서로 멀리 떨어져 있어 프로세서가 계속해서 돌아다녀야 하기 때문에 느림
  - 현대 프로세서는 메모리 내부를 이리저리 왔다 갔다 하는 작업이 적을 수록 빨라질수 있음
  - 힙 영역처럼 데이터가 서로 멀리 떨어져 있으며 작업이 느려지고, 반대로 스택 영역처럼 데이터가 서로 붙어 있으면 작업이 빨라짐
- 함수를 호출하면, 호출한 함수에 넘겨준 값(값 중엔 힙 영역의 데이터를 가리키는 포인터도 있을 수 있음)과 해당 함수의 지역 변수들이 스택에 푸시됨
  - 그리고 이 데이터들은 함수가 종료될 때 팝(제거)됩니다.
- 코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 작업은 모두 소유권과 관련있음
  - 즉, **소유권의 주요 목표가 힙 데이터의 관리라는 점을 알고 있으면 소유권의 동작 방식을 이해하는 데 도움**

### 소유권 규칙
다음 규칙을 명심합시다.
- 러스트에서, 각각의 값은 *소유자(owner)* 가 정해져 있음
- 한 값의 소유자는 동시에 여럿 존재할 수 없음
- 소유자가 스코프 밖으로 벗어날 때, 값은 버려짐(`dropped`)

### 변수의 스코프
- 소유권 예제 1) 변수의 스코프(scope)
  - 스코프란 프로그램 내에서 아이템이 유효한 범위를 말함
```rust
fn main() {
    {
        let s = "hello";    // 여기서 부터 s 변수가 유효한 지점
        // s로 어떤 작업을 함
    }                       // 이 스코프가 종료되었고, s가 더 이상 유효하지 않음
}
```
- 중요한 두 가지
  - `s`가 스코프 내에 나타나면 유효함
  - 유효기간은 스코프 밖으로 벗어나기 직전까지

### `String` 타입
여기서 `String`의 소유권과 관련된 부분에만 집중해보겠습니다. 이러한 관점은 표준 라이브러리가 제공하는 다른 타입들이나 만들어볼 복잡한 복잡한 데이터 타입에도 적용됩니다.
여태 보아온 문자열은 코드 내에 하드코딩하는 방식의 문자열 리터럴이었습니다. 문자열 리터럴은 쓰기 편리하지만, 만능은 아닙니다. 그이유는 문자열 리터럴이 불변성(immutable)을 지니기에 변경할 수 없다는 점과 프로그램에 필요한 모든 문자열을 우리가 프로그래밍하는 시점에 알 수는 없다는 점 때문입니다. 사용자한테 문자열을 입력받아 저장하는 기능 등을 만들어야 하는 상황에서는 문자열 리터럴을 사용할 수 없습니다.
따라서 러스트는 또 다른 문자열 타입인 `String`을 제공합니다. 이 타입은 힙에 할당된 데이터를 다루기 때문에, 컴파일 타임에 크기를 알 수 없는 텍스트도 저장할 수 있습니다.
`String` 타입은 다음과 같이 `from` 함수와 문자열 리터럴을 이용해 생성이 가능합니다.
```rust
let s = String::from("hello");
```
- 이중콜론`::`은 우리가 함수를 사용할 대 `string_from` 같은 함수명을 사용하지 않고 `String` 타입에 있는 특정된 `from` 함수라는 것을 지정할 수 있게 해주는 네임스페이스 연산자
  
이 `String` 문자열은 변경이 다음과 같이 변경 가능합니다.
```rust
let mut s = String::from("hello");
s.push_str(", world!");
println!("{}", s);  // hello, world!
```
이 처럼 문자열 리터럴과 `String`에 무슨 차이가 있어 어떤 것은 변경 가능하고 어떤 것은 변경할 수 없을까요? 차이점은 **각 타입의 메모리 사용 방식** 에 있습니다.


### 메모리와 할당
- 문자열 리터럴은 컴파일 타임에 내용을 알 수 있음
  - 텍스트가 최종 실행파일에 하드코딩됨
    - 이 방식은 빠르고 효율적이지만, 문자열이 변하지 않을 경우에만 사용가능
    - 컴파일 타임에 크기를 알 수 없고 실행 중 크기가 변할 수도 있는 텍스트는 바이너리 파일에 집어넣을 수 없음
- `String` 타입은 힙에 메모리를 할당하는 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있음
  - 실행 중 메모리 할당자로부터 메모리를 요청해야함
    - `String::from` 호출 시, 필요한 메모리를 요청하도록 구현되어 있음
      - 프로그래밍 언어 사이에서는 일반적으로 사용하는 방식
  - `String` 사용을 마쳤을 때 메모리를 해제할(즉, 할당자에게 메모리를 반납할) 방법이 필요
    - *가비지 컬렉터(garbage collector, GC)* 를 갖는 언어에서는 GC가 사용하지 않는 메모리를 찾아 없애주므로 프로그래머가 신경 쓸 필요가 없음
    - GC가 없는 대부분의 언어에서는 할당받는 메모리가 필요 없어지는 지점을 프로그래머가 직접 찾아 메모리 해제 코드를 작성해야 함
      - 이것은 많은 프로그래머가 실수하는 부분이며 많은 경우 버그를 일으킴
      - 따라서 `allocate`와 `free`가 하나씩 짝짓도록 만들어야함
    - 러스트에서는 이 문제를 **변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결**
      - **러스트는 변수가 스코프 밖으로 벗어나면 `drop`이라는 특별한 함수를 호출함**
      - `drop` 함수는 닫힌 중괄호(`}`)가 나타나는 지점에서 자동으로 호출됨

### 변수와 데이터 간 상호작용 방식: 이동
```rust
let x = 5;
let y = x;
```
x와 y는 정수형 값으로 크기가 정해진 단순한 값이기 때문에 두 5값은 스택에 푸시됩니다.

```rust
let s1 = String::from("hello");
let s2 = s1;
```
힙 메모리에 `hello`를 저장하고 실제 s1은 메모리의 저장된 `hello` 문자열의 주소값을 저장합니다.
구체적으로는 포인터, 길이, 용량을 모두 가집니다. 이 데이터는 스택에 저장됩니다.
그리고 실제 `hello` 문자열은 힙 메모리에 저장됩니다.
  
- case1) s1을 s2에 대입하면 `String` 데이터가 복사됨
  - 이때 데이터는 스택에 있는 데이터, 즉 포인터, 길이, 용량 값을 말함
  - 포인터가 가리키는 힘 영역의 데이터가 복사되지 않음
  - 즉, s1, s2 `hello`가 위치한 메모리 위치를 가짐
- case2) 만약 s1, s2가 힙 메모리의 데이터까지 복사할 경우 러스트가 계속해서 이런 방식으로 동작한다면 힙 내 데이터가 커질 수록 `s2 = s1` 연산은 굉장히 느려질 것으로 예상됨

`case1` 처럼 두 포인터가 같은 곳을 가리킬 경우는 s2, s1이 스코프 밖으로 벗어날 때 각각 메모리를 해제하게 되면 *중복 해제(double free)* 에러가 발생할 것입니다.
이는 메모리 안정성 버그 중 하나이며 보안을 취약하게 만드는 메모리 손상의 원인입니다.
  

메모리 안정성을 보장하기 위해서, 러스트는 `let s2 = s1;` 라인 뒤로는 `s1`이 더 이상 유효하지 않다고 판단합니다.
이로써 러스트는 `s1`이 스코프를 벗어나더라도 아무것도 해제할 필요가 없습니다. 
`s2`가 만들어진 이후에 `s1`을 사용하는 경우 어떤 일이 생기는지 확인해보면, 작동하지 않음을 알 수 있습니다.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1); // error[E0382]: borrow of moved value: `s1`
    // 유효하지 않은 참조값의 사용을 감지했다는 에러 발생
}
```
러스트에서는 기존의 변수를 무효화하기 때문에 이를 복사가 아닌 *이동(move)* 라고 하며, 
앞선 코드는 *`s1`이 `s2`로 소유권이 이동되었다* 라고 표현합니다.
이로써 `s2`만이 유효하니, 스코프 밖으로 벗어났을 때 자신만 메모리를 해제할 것이고,
문제가 해결됩니다.  
실제로 러스트는 절대 자동으로 '깊은' 복사로 데이터를 복사하는 일은 없습니다.
따라서, 러스트가 자동으로 수행하는 모든 복사는 런타임 성능 측면에서 효율적이라 할 수 있습니다.

### 변수와 데이터 간 상호작용 방식: 클론
`String`의 힙 데이터까지 깊이 복사하고 싶을 땐 `clone`이라는 공용 메서드를 사용할 수 있습니다.
```rust
fn main() {
  let s1 = String::from("hello");
  let s2 = s1.clone();
  
  println!("s1 = {}, s2 = {}", s1, s2);
}
```

### 스택에만 저장되는 데이터: 복사
```rust
fn main() {
  let x = 5;
  let y = x;
  
  println!("x = {}, y ={}", x, y);
}
```
`clone`을 호출하지 않았는데 `x`는 계속해서 유효하며 `y`로 이동(move)되지도 않았습니다.  
이유는 정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되기 때문입니다.
스택에 저장되니, 복사본을 빠르게 만들 수 있고, 따라서 굳이 `y`를 생성하고 나면 `x`를 무효화할 필요가 없습니다.
다시 말해 이런 경우엔 깊은 복사와 얕은 복사 간에 차이가 없습니다. 여기선 `clone`을 호출해도 얕은 복사와 차이가 없으니 생략해도 상관없습니다.
  
러스트에는 정수형처럼 스택에 저장되는 타입을 달아 놓을 수 있는 `Copy` 트레이트가 있습니다.
- 만약 어떤 타입에 이 `Copy` 트레이트가 구현되어 있다면, 이 타입의 변수는 사용되어도 이동(move)되지 않고 자명하게 복사되고, 대입연산 후에도 사용할 수 있음
- 구현하려는 타입이나, 구현하려는 타입 중 일부분에 `Drop` 트레이트가 구현된 경우엔 `Copy` 트레이트를 어노테이션 할 수 없음
- 스코프 밖으로 벗어났을 때 특정 동작이 요구되는 타입에 `Copy` 어노테이션을 추가하면 컴파일 에러가 발생

`Copy` 가능한 타입은?
> 일반적으로 단순한 스칼라 묶음은 `Copy` 가능하고, 할당이 필요하거나 리소스의 일종인 경우엔 불가능합니다.
- 모든 정수형 타입(예: `u32`)
- `true`, `false` 값을 갖는 논리 자료형 `bool`
- 모든 부동 소수점 타입(예: `f64`)
- 문자 타입 `char`
- `Copy` 가능한 타입만으로 구성된 튜플(예를 들어, `(i32, i32)`는 `Copy` 가능, `(i32, String)`은 불가능)

### 소유권과 함수
- 함수로 값을 전달하는 메커니즘은 변수에 값을 대입할 때와 유사함
  - 함수에 변수를 전달하면 대입 연산과 마찬가지로 이동이나 복사가 일어나기 때문
```rust
fn main() {
  let s = String::from("hello");
  
  takes_ownership(s); // s의 소유권은 takes_ownership으로 이동
  
  let x = 5;
  
  makes_copy(x);    // x는 함수로 이동(move)되지만 i32는 Copy이므로 앞으로 x를 계속해서 사용할 수 있음
}

fn takes_ownership(some_string: String) {
  println!("{}", some_string);
}   // 여기서 some_string이 스코프 밖으로 벗어나고 `drop`이 호출됨
    // 메모리가 해제됨

fn makes_copy(some_integer: i32) {
  println!("{}", some_integer);
}   // 여기서 some_integer가 스코프 밖으로 벗어남, 별다른 일이 발생하지 않음
```
- `takes_ownership` 함수를 호출한 이후에 `s`를 사용하려할 경우, 컴파일 타임 에러를 발생시킴


### 반환 값과 스코프
소유권은 값을 반환하는 과정에서도 이동(move)합니다.
```rust
fn main() {
  let s1 = gives_ownership();   // gives_ownership이 자신의 반환값을 s1로 이동(move)
  
  let s2 = String::from("hello");   // s2가 스코프 안으로 들어옴
  
  let s3 = takes_and_gives_back(s2);    // s2는 takes_and_gives_back로 이동
                                        // 이 함수 또한 자신의 반환 값을 s3로 이동
}

fn gives_ownership() -> String {
  let some_string = String::from("yours");
  some_string   // some_string이 반환되고 호출자 함수 쪽으로 이동
}

fn takes_and_gives_back(a_string: String) -> String {
  a_string  
}
```
- 상황은 다양할지라도, 변수의 소유권 규칙은 언제나 동일함
- 어떤 값을 다른 변수에 대입하면 값이 이동하고, 힙에 데이터를 갖는 변수가 스코프를 벗어나면, 사전에 해당 데이터가 이동하여 소유권이 다른 변수에 이동되지 않은 이상 `drop`에 의해 데이터가 제거됨

```rust
fn main() {
  let s1 = String::from("hello");
  
  let (s2, len) = calculate_length(s1);
  
  println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
  let length = s.len(); // len()은 String의 길이를 반환

  (s, length)
}
```
- 하지만 이런 식은 일반적인 컨셉이 되기엔 너무 거추장스러움
- 러스트에는 소유권 이동 없이 값을 사용할 수 있는 *참조자(reference)* 라는 기능을 가지고 있음


## 참조와 대여
위 예제의 `calculate_length`를 호출한 함수로 `String`을 반환하여, 함수 호출 이후에도 `String`을 사용할 수 있게 했습니다.
이렇게 하는 대신 `String` 값의 참조자를 만들 수 있습니다.  
  
*참조자(reference)* 는 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값에 해당하는 포인터와 같은 것입니다.
데이터는 다른 어떤 변수가 소유하고 있습니다. 포인터와는 달리, 참조자는 살아있는 동안 특정 타입에 대한 유효한 값을 가리킴을 보장해 줍니다.

```rust
fn main() {
  let s1 = String::from("hello");
  
  let len = calculate_length(&s1);  // &s1 참조값을 매개변수로 할당
  
  println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
  s.len()
}
```
- 앤퍼센트(`&`) 기호자는 *참조자*를 나타내고, 어떤 값의 소유권을 가져오지 않고 해당 값을 참조할 수 있도록 해줌
- `&String s`는 `String s1`을 가리킴

> Note: `&`를 이용한 참조의 반대는 *역참조(dereferencing)*라고 합니다. 역참조 기호는 `*`입니다. 15장에서 자세한 내용을 다룹니다.

```rust
let s1 = String::from("hello");
let len = calculate_length(&s1);
```
- `s1`에 `&`를 붙인 `&s1` 구문은 `s1` 값을 참조하지만 해당 값을 소유하지 않는 참조자를 생성
- 값을 소유하지 않으므로 이 참조자가 가리킨 값은 참조자가 사용되지 않을 때까지 버려지지 않음

```rust
fn calculate_length(s: &String) -> usize {
  s.len()
}
```
- 함수 시그니처에도 `&`를 사용하여 `s`가 참조자 타입임을 나타냄
- `s`에는 소유권이 없으므로 `s`가 더 이상 사용되지 않을 때도 이 참조자가 가리킨 값이 버려지지 않음
- 함수가 실제 값 대신 참조자를 매개변수로 쓴다면 애초에 소유권이 없으니까 이 소유권을 돌려주기 위한 값 반환도 필요 없어짐
- 이처럼 참조자를 만드는 행위를 *대여(borrow)* 라고 함
  
빌린 값을 수정하는 경우?
```rust
fn main() {
  let s = String::from("hello");
  change(&s);   // error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
}

fn change(s: &String) {
  s.push_str(", world");
}
```
- **변수가 기본적으로 불변성을 지니듯, 참조자도 참조하는 것을 수정할 수 없음**

### 가변 참조자
*가변 참조자(mutable reference)* 를 사용하는 식으로 예제를 수정해봅시다.
```rust
fn main() {
  let mut s = String::from("hello");
  change(&mut s);
}

fn change(s: &mut String) {
  s.push_str(", world");
}
```
- `s`를 `mut`로 변경함
- `change` 함수의 매개변수에도 `s`가 `mut`임을 명시적으로 남김 
  
가변 참조자는 한 가지 큰 제약사항이 있습니다. 어떤 값에 대한 가변 참조자가 있다면, 그 값에 대한 참조자는 더 이상 만들 수 없습니다.
아래 코드는 작동하지 않습니다.
```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2); // error[E0499]: cannot borrow `s` as mutable more than once at a time
```
- 가변 `s`를 두번 이상 빌려올 수 없기 때문에 발생하는 에러
  
이러한 제약은 값의 변경에 대한 제어가 원활하도록 해줍니다.
이 제약 덕분에 러스트에서는 컴파일 타임에 *데이터 경합(data race)* 을 방지할 수 있습니다.
데이터 경합이란 다음 세 가지 상황이 겹칠 때 일어나는 특정한 경합 조건(race condition)입니다.
- 둘 이상의 포인터가 동시에 같은 데이터에 접근
- 포인터 중 하나 이상이 데이터에 쓰기 작업을 시행
- 데이터 접근 동기화 메커니즘이 없음
  
데이터 경함은 정의되지 않은 동작을 일으키며, 런타임에 추적하려고 할 때 문제 진단 및 수정이 어렵습니다.
  
중괄호로 새로운 스코프를 만들어, 가변 참조자를 여러 개 만들면서 *동시에 존재하는 상황* 을 회피하는 방법도 있습니다.
```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
}

let r2 = &mut s;
```
  
가변 참조자와 불변 참조자를 혼용할 때도 유사한 규칙이 적용됩니다. 다음 코드는 컴파일 에러가 발생합니다.
```rust
let mut s = String::from("hello");

let r1 = &s;    // 문제없음
let r2 = &s;    // 문제없음
let r3 = &mut s;    // 문제

println!("{}, {}, and {}", r1, r2, r3); // error[0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
```
- 어떤 값에 대한 불변 참조자가 있는 동안 같은 값의 가변 참조자를 만드는 것 또한 불가능합니다.
- 불변 참조자를 사용하는 쪽에서는 사용 중 값이 중간에 변경되리라 예상하지 않음
- 데이터를 읽기만 하는 기능으로는 다른쪽에서 값을 읽는 기능에 영향을 주지 않으므로, 여러 개의 불변 참조자를 만드는 것은 가능함

```rust
let mut s = String::from("hello");

let r1 = &s; // 문제없음
let r2 = &s; // 문제없음
println!("{} and {}", r1, r2);
// 이 지점 이후로 변수 r1과 r2는 사용되지 않습니다

let r3 = &mut s; // 문제없음
println!("{}", r3);
```

### 대글링 참조
> *댕글링 포인터(dangling pointer; 매달린 포인터)* 란, 어떤 메모리를 가리키는 포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써,
다른 개체가 할당받았을지도 모르는 메모리를 참조하게 된 포인터를 말합니다. 포인터가 있는 언어에서는 자칫 잘못하면 이 댕글링 포인터를 만들기 쉽습니다.
하지만 러스트에서는 어떤 데이터의 참조자를 만들면, 해당 참조자가 스코프를 벗어나기 전에 데이터가 먼저 스코프를 벗어나는지 확인하여 댕글링 참조가 생성되지 않도록 보장합니다.
  
댕글링 참조를 만들어서 러스트가 어떤 식으로 이것을 컴파일 타임에 방지하는지 살펴봅시다:

```rust
fn main() {
  let reference_to_nothing = dangle();
}

fn dangle() -> &String {    // error[E0106]: missing lifetime specifier
  let s = String::from("hello");
  &s
}
```
- lifetime 이라는 에러 메시지가 등장(10장에서 다룰 예정)
- `s`는 `dangle` 함수 내에서 생성됐기 때문에, 함수가 끝날 때 할당 해제됨
  - 코드에서 `&s`를 반환하는 과정에서 유효하지 않는 `String`을 가리키는 참조자를 반환하는 행위이기 때문에 에러 발생
- 이 경우 해결방법으로 `String`을 직접 반환
```rust
fn no_dangle() -> String {
  let s = String::from("hello");
  s
}
```
소유권은 이동되며, 할당 해제되지도 않습니다.


## 슬라이스
- 컬렉션(collection; 데이터 구조의 목록과 같은 형식)을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 해줌
- 참조자의 일종으로서 소유권을 갖지 않음

공백문자로 구분된 단어들의 문자열을 입력받아서 해당 문열의 첫 번째 단어를 반환하는 함수
```rust
fn main() {
    let s: String = String::from("hello world!");
    
    let blank_index = first_words(&s);
    println!("{}", blank_index);
}

fn first_words(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```
- `String`을 하나하나 쪼개서 해당 요소가 공백 값인지 확인해야 하므로, `as_bytes` 메서드를 이용해 바이트 배열로 변환
```rust
let bytes = s.as_bytes();
```
- 그 다음, 바이트 배열에 사용할 반복자(iterator)를 `iter` 메서드로 생성
```rust
for (i, &item) in bytes.iter().enumerate() { ...
```
  - 반복자(iterator)는 `13장`에서 자세히 살펴볼 예정
  - `iter` 메서드는 컬렉션의 각 요소를 반환
    - `enumerate` 메서드는 `iter`의 각 결과값을 튜플로 감싸 반환
      - 이때 반환하는 튜플은 첫번째 요소가 인덱스, 두 번째 요소가 해당 요소의 참조자로 이루어짐
      - `i`는 튜플 요소 중 인덱스, `&item`은 바이트에 대응
        - `&`를 사용하는 이유는 `iter().enumerate()`에서 얻은 요소의 참조자가 필요하기 때문
```rust
      if item == b' ' {
          return i;
      }
  }

  s.len()
```
- `for` 반복문 내에서는 바이트 **리터럴 문법** 으로 공백문자를 나타내는 바이트를 찾고, 찾으면 해당 위치를 반환
- 찾지 못한 경우엔 s 문자열의 길이를 리턴

이 함수에는 문제가 있습니다. `usize`를 반환하고 있는데, 이는 `&String` 컨텍스트에서만 의미 있는 숫자일 뿐입니다. 바꿔 말하면, `String`과는 별개의 값이기 때문에 향후에도 유효하다는 보장이 없습니다.

```rust
// first_word 함수의 결과를 저장했으나, 이후에는 String의 내용물이 변경된 상황
fn main() {
  let mut s = String::from("hello world");
  let word = first_word(&s);  // word는 값 5를 받음
  s.clear();  // clear()는 String을 비워서 ""으로 만듬
}
```
이 코드는 정상적으로 컴파일되지만, `s.clear()`를 호출한 후에 `word`를 사용하는 코드를 작성하더라도 `word`는 `s`와 분리되어 있느니 결과는 동일하다. 하지만, `word`에 담긴 값 `5`를 본래 목적대로 `s`에서 첫 단어를 추출하는데 사용할 경우 버그를 유발할 수도 있습니다. `s`의 내용물은 변경되었기 때문에...

만약 두 번째 단어를 찾는 함수를 만든다면 시작과 끝 두 인덱스가 필요할 것이고 앞선 예제와 같이 어떤 데이터의 특정 상태에만 의존하는 값들이 늘어남을 의미하게 됩니다.  
다행히도, 러스트에는 문자열 슬라이스라는 적절한 대안이 존재합니다.

### 문자열 슬라이스
- `String`의 일부를 가리키는 참조자를 말함
```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```
- `[starting_index..ending_index]`의 슬라이스를 생성한다는 의미
- 슬라이스는 내부적으로 시작위치, 길이를 데이터 구조에 저장하며, 길이 값은 `ending_index` 값에서 `starting_index`를 빼서 계산
  
`..` 범위 표현법은 인덱스 0부터 시작하는 경우, 앞의 값을 생략할 수 있습니다.  
혹은 `String`의 맨 마지막 바이트까지 포함하는 슬라이스는 뒤의 값을 생략할 수 있습니다.
```rust
let s = String::from("hello world");

let hello = &s[..5];
let world = &s[6..];

let len = s.len();
let world = &s[6..len];
```
  
앞뒤 인덱스를 모두 생략할 경우, 전체 문자열이 슬라이스로 생성됩니다. 아래 두 `hello`는 동일합니다.
```rust
let s = String::from("hello");

let len = s.len();
let hello = &s[0..len];
let hello = &s[..];
```
> Note: 위 예시에서는 ASCII 문자만 사용하여 문제가 없었지만, UTF-8 문자열 슬라이스 생성 시 인덱스는 반드시 올바른 UTF-8 문자 경계로 지정되어야 합니다. 멀티 바이트 문자의 중간 부분에서 슬라이스를 생성한 경우, 프로그램은 에러와 함께 강제 종료됩니다. UTF-8 문자를 다루는 방법은 8장에서 자세히 알아봅시다.
  
슬라이스를 사용하여 `first_word` 함수를 다시 작성해봅시다.
```rust
fn first_words(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```
- `first_word`가 반환하는 값은 원래 데이터와 분리된 값이 아닙니다. 이 값은 원래 데이터에서 슬라이스 시작 위치를 가리키는 참조자와 슬라이스 요소 개수로 구성되어 있습니다.
  
```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // 에러!

    println!("the first word is: {}", word);
}
```
- `clear` 함수 실행 후 `println!`는 word의 참조자를 사용하므로 에러가 발생
- 이 불변 참조자는 이 지점까지 계속 활성화 되어 있어야 함

#### 슬라이스로써의 문자열 리터럴
문자열 리터럴은 바이너리 내에 저장된다는 이야기를 잠깐 언급했습니다. 슬라이스를 배웠으니, 문자열 리터럴도 제대로 이해해 봅시다.
```rust
let s = "Hello world!;
```
- 여기서 `s`는 바이너리의 특정 지점을 가리키는 슬라이스
  - `&str` 타입
  - `&str`은 불변 참조자이므로, 문자열 리터럴은 변경할 수 없음

#### 문자열 슬라이스를 매개변수로 사용하기
리터럴과 `String`의 슬라이스를 만들 수 있다는 것을 알고나면 `first_word` 함수를 다음과 같이 작성할 수 있습니다.
```rust
fn first_word(s: &String) -> &str {
```
좀 더 경험이 많은 러스타시안은 다음 예제와 같이 `&String` 값과 `&str` 값 모두 사용 가능한 함수를 작성할 것입니다.
```rust
fn first_word(s: &str) -> &str {
```
문자열 슬라이스라면 이를 바로 인수로써 전달할 수 있습니다. `String`이라면 `String`의 슬라이스 혹은 `String`에 대한 참조자를 전달할 수 있습니다. 이러한 유연성은 *역참조 강제(deref coercions)* 기능을 이용하는데, 15장에서 다룹니다.
  
`String`에 대한 참조자 대신에 문자열 슬라이스를 매개변수로 하는 함수로 정의하면 기능 면에서 손해보지 않으면서 API를 더 일반적이고 유용하게 만들어줍니다.

```rust
fn main() {
    // let s: String = String::from("hello world!");
    
    // let first_word = first_words(&s);
    // println!("{}", first_word);

    let my_string = String::from("hello world");
    // 'first_word'는 String의 일부 혹은 전체 슬라이스에 대해 작동함
    let word1 = first_word(&my_string[0..6]);
    println!("{}", word1);
    let word2 = first_word(&my_string[..]);
    println!("{}", word2);
    // 또한 'first_word'는 String의 전체 슬라이스와 동일한 String의 참조자에 대해서도 다룹니다.
    let word3 = first_word(&my_string);
    println!("{}", word3);

    let my_string_literal = "hello world";
    // 문자열 리터럴은 곧 문자열 슬라이스이므로, 아래 코드도 슬라이스 문법 없이 작동합니다.
    let word4 = first_word(my_string_literal);
    println!("{}", word4);
}
```

### 그 외 슬라이스
문자열 슬라이스는 문자열에만 특정되어 있습니다. 더 범용적인 슬라이스 타입도 존재합니다. 
```rust
let a = [1, 2, 3, 4, 5];
```
  
문자열 일부를 참조할 때처럼 다음과 같이 배열 일부를 참조하고 싶다면 다음과 같이 할 수 있습니다.
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```
이 슬라이스는 `&[i32]` 타입입니다. 동작 방식은 문자열 슬라이스와 동일합니다. 슬라이스의 첫 번째 요소를 참조하는 참조자와 슬라이스의 길이를 저장하여 동작합니다. 이런 슬라이스는 모든 컬렉션에 사용가능합니다. 컬렉션은 8장에서 자세히 알아봅니다.
